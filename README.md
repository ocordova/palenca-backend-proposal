# Proposal of API project

With this proposal, I solve this pain points:

- Remove mix of database and business rules
- Remove dependency of database models
- Same error response schemas
- API documentation that always matches the code
- Easy API versioning implementation
- Easy implementation of different authentication types
- Detect if the 3rd party APIs response schema changed
- Isolate sandbox from production
- Documentation of 3rd party api dependencies
- Easier testing with unit test and integrations tests

## Architecture

![Architecture Diagram](_diagrams/palenca_architecture.png?raw=true)

## Git Repos

For better developer experience and maintainability I propse this repos
configuration:

[Reference for the documentation strategy](https://opstrace.com/blog/product-documentation-with-nextjs)

![Repos Diagram](_diagrams/palenca_repos.png?raw=true)

## Requirements

- [Docker](https://www.docker.com/get-started)
- [pre-commit](https://pre-commit.com) (see
    [code formatting](#code-formatting) section)

## Steps to run the whole project

This will run API and the Mock API with network connection between the
containers

```bash
docker-compose up
# http://localhost:8000 for API
# http://localhost:9000 for Mock API
```

## Open API

FastAPI autogenerates the [OpenAPI Specification](https://www.openapis.org/).
Once you run the project, you can view them with Swagger UI and ReDoc:

```bash
# API docs url
Swagger: http://localhost:8000/docs
ReDoc: http://localhost:8000/redoc

# Mock API docs ulr
# You need to prefix the <sub_application_name>, for example for pedidosya:
Swagger: http://localhost:9000/pedidosya/docs
ReDoc: http://localhost:9000/pedidosya/redoc

```

## Steps to run the API only

```bash
docker build -t api -f Dockerfile.development .
docker run -it -v "$(pwd)":/opt/api:cached -p 8000:8000 api /bin/bash -l
python -m api.app
```

## Steps to run the Mock API only

```bash+
docker build -t mock -f Dockerfile.mock.development .
docker run -it -v "$(pwd)":/opt/api:cached -p 9000:9000 mock /bin/bash -l
python -m mock.app
```

## Run tests

```bash
# Run the project
docker ps # or `docker container ls` to get container id
docker exec -it CONTAINER_ID /bin/bash -l # Run bash in th container
pytest -n auto --timeout=5

```

## Run coverage

```bash
# Run the project
docker ps # or `docker container ls` to get container id
docker exec -it CONTAINER_ID /bin/bash -l
pytest --cov-report term-missing --cov=api --cov=mock

```

## Environment variables

The project needs environment variables to be set, to run correctly. See
`misc/config.py` for a list of them. You can set them inside the Dockerfiles

## Migrations ([Aerich](https://github.com/tortoise/aerich))

Run migrations

```bash
aerich upgrade
```

Create migration

```bash
aerich migrate --name create_app_login_table
```

Downgrade

```bash
aerich downgrade
```

## Code Formatting

To maintain the same style throughout the code, we use the following tools:

- [Black](https://github.com/psf/black): Code formatter
- [Autoflake](https://github.com/PyCQA/autoflake): Removes unused imports and
    variables
- [Mypy](https://github.com/python/mypy): Static type checker
- [isort](https://github.com/PyCQA/isort): Sort imports
- [markdownlint-cli](https://github.com/igorshubovych/markdownlint-cli): Markdown
    linter

To ensure this, we use [pre-commit](https://pre-commit.com/) to run as git hook.
Follow [pre-commit installation instructions](https://pre-commit.com/#install)
for your development environment and setup the git hooks scripts.

```bash
pip install pre-commit
pre-commit install
```

## Project Structure

```markdown
api                      # API Project following Clean Arch. (see section below)
   |-- app.py            # Main application start point
   |-- data              # Models, Repositories, Fakers
       |-- tests
   |-- domain            # Entities, enums, adapters, usecases
       |-- tests
   |-- presentation      # Resources, response models and validations
       |-- tests
   |-- misc              # Config and utils
   |-- migrations               # Migration files generated by Aerich

mock                     # Mock API Project
   |-- <sub_app>         # Sub apps follwinf Clean Arch. (see section below)
       |-- domain        # Entities, enums, adapters, usecases
           |-- tests
       |-- presentation  # Resources, response models and validations
           |-- tests
   |-- misc              # Config and utils
requirements             # Both projects requirements. See section below
```

### Base

- [FastAPI](https://fastapi.tiangolo.com/): Web framwork for the API
    endpoints, OpenAPI Documentation and Request validation
- [Tortoise ORM](https://tortoise-orm.readthedocs.io/en/latest/): asyncio ORM
    for Postgres
- [Aerich](https://github.com/tortoise/aerich): Migration tool for Tortoise
    ORM (Example)
- [cuid](https://github.com/ericelliott/cuid): Collision-resistant ids
    (Example)
- [bcrypt](https://github.com/pyca/bcrypt/): Password hashing tool (Example)

### Testing

- [pytest](https://docs.pytest.org/): Framework for testing
- [Hypothesis](https://hypothesis.works/): Framework used by some test to
    generate test data
- [Factory boy](https://factoryboy.readthedocs.io/en/stable/): Fixtures
    replacement tool for tortoise models
- [Pydantic Factories](https://github.com/Goldziher/pydantic-factories): Mock
    data for pydantic models

## Clean Architecture

This project is following the
[Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
software design philosophy.

![Clean Architecture Diagram](_diagrams/clean_architecture.jpg?raw=true)

## Modules

### Entities

`domain/entities` Entities are native business objects of this project. In this
project, examples are Client, User, Platform, AppLogin. An entity is typically
saved to the database using a repository method (see below), but it can also
have been fetched from other apis using HTTP.

`domain/enums` We use enums to guarantee the uniqueness of constant values

### Adapters

`domain/adapters` The adapters are functions that convert a database model or
third party api model to an entity.

### Repositories

`data/repositories` The functions receive entities and change the database in a
specific way or connect with an api to retrieve information. The functions that
return entities typically have to use an adapter to convert the model instance
to an entity. In this way, the database or third party api is abstracted from
the business logic.

### Use cases

`domain/usecases` The use cases contains the actual business logic. For example,
what to do if someone logins to a platform? The use case checks the platform is
online, that the platform is available in the country, notify to socket or
webhooks.

The use cases typically call repository methods.

### Exceptions

`domain/exceptions` Exceptions that are typically raised by use cases. They can
be converted to JSON, and returned to the HTTP client and typically include a
link to the documentation.

### Resources

`presentation/resources` Are built using FastAPI dependency. They use
validations to parse HTTP requests data. They call the use cases. They also
check the authentication, encode the Exceptions into JSON an serialize the
responses and can detect the api version to call a specific usecase or return a
different response schema.

### Validations

`presentation/validations` Endpoint payload validation are build using pydantic
library, they are used by FastAPI to parse and validate the data. A lot of
schemata corresponds to an entity or enum.

### Responses

`presentation/reponses` Endpoint JSON response are build using the pydantic
library, they are used by FastAPI to serialize them.
